name: libexecinfo CI/CD

on:
  push:
    branches: ["main"]
    paths:
      - '**.c'
      - '**.h'
      - '**.py'
      - 'Makefile'
      - '.github/workflows/**'
  pull_request:
    branches: ["main"]
  workflow_dispatch:

env:
  DEBIAN_FRONTEND: noninteractive

# Add permissions at the workflow level
permissions:
  contents: write
  packages: write

jobs:
  build-and-test:
    runs-on: ubuntu-latest
    strategy:
      matrix:
        compiler: [gcc, clang]
        build_type: [debug, release]

    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Cache dependencies
      uses: actions/cache@v4
      with:
        path: |
          /var/cache/apt/archives
        key: ${{ runner.os }}-apt-${{ hashFiles('**/Makefile') }}
        restore-keys: |
          ${{ runner.os }}-apt-

    - name: Install dependencies
      run: |
        sudo apt-get update -qq
        sudo apt-get install -y \
          build-essential \
          python3 \
          pkg-config \
          binutils-dev \
          libc6-dev \
          clang \
          valgrind \
          gdb \
          libbfd-dev \
          libiberty-dev

    - name: Set compiler
      run: |
        if [ "${{ matrix.compiler }}" = "clang" ]; then
          echo "CC=clang" >> $GITHUB_ENV
        else
          echo "CC=gcc" >> $GITHUB_ENV
        fi

    - name: Set build type
      run: |
        if [ "${{ matrix.build_type }}" = "debug" ]; then
          echo "DEBUG=1" >> $GITHUB_ENV
          echo "CI=1" >> $GITHUB_ENV
        else
          echo "DEBUG=0" >> $GITHUB_ENV
        fi

    - name: Generate source files
      run: make generate

    - name: Build static library
      run: make static

    - name: Build dynamic library
      run: make dynamic

    - name: Build test program
      run: make test

    - name: Run basic tests
      run: |
        # Enable core dumps for debugging crashes
        ulimit -c unlimited
        export LD_LIBRARY_PATH=".:${LD_LIBRARY_PATH}"

        # For clang release builds, use more conservative settings and enhanced gdb output
        if [ "${{ matrix.compiler }}" = "clang" ] && [ "${{ matrix.build_type }}" = "release" ]; then
          echo "Running conservative test for clang release build..."
          timeout 30s ./test || {
            echo "Test failed or timed out, checking with gdb (full backtrace)..."
            gdb -batch -ex "set pagination off" -ex "run" -ex "bt full" -ex "info locals" -ex "info registers" -ex "quit" --args ./test
            exit 1
          }
        else
          ./test
        fi

        echo "Testing pkg-config generation..."
        make libexecinfo.pc
        pkg-config --validate libexecinfo.pc

    - name: AddressSanitizer (ASan) check (Debug builds only)
      if: matrix.build_type == 'debug'
      run: |
        export LD_LIBRARY_PATH=".:${LD_LIBRARY_PATH}"
        ASAN_OPTIONS=detect_leaks=1:abort_on_error=1 ./test

    # Rebuild without ASan for Valgrind memory leak check
    - name: Memory leak check (Valgrind, debug/gcc only, non-ASan build)
      if: matrix.build_type == 'debug' && matrix.compiler == 'gcc'
      run: |
        make clean
        make DEBUG=0 test
        export LD_LIBRARY_PATH=".:${LD_LIBRARY_PATH}"
        valgrind --leak-check=full --show-leak-kinds=all --track-origins=yes --error-exitcode=1 ./test

  create-release:
    if: github.ref == 'refs/heads/main' && github.event_name == 'push'
    needs: build-and-test
    runs-on: ubuntu-latest

    # Add specific permissions for this job
    permissions:
      contents: write
      packages: write

    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      with:
        fetch-depth: 0
        # Use a personal access token instead of the default GITHUB_TOKEN
        token: ${{ secrets.LIBEXEC_TOKEN }}

    - name: Install dependencies
      run: |
        sudo apt-get update -qq
        sudo apt-get install -y \
          build-essential \
          python3 \
          pkg-config \
          tar \
          gzip \
          gh \
          binutils-dev \
          libbfd-dev \
          libiberty-dev

    - name: Authenticate GitHub CLI
      run: |
        echo "${{ secrets.LIBEXEC_TOKEN }}" | gh auth login --with-token

    - name: Generate version info
      id: version
      run: |
        VERSION_MAJOR=$(grep "^VERSION_MAJOR" Makefile | head -1 | cut -d'=' -f2 | tr -d ' ')
        VERSION_MINOR=$(grep "^VERSION_MINOR" Makefile | head -1 | cut -d'=' -f2 | tr -d ' ')
        VERSION_PATCH=$(grep "^VERSION_PATCH" Makefile | head -1 | cut -d'=' -f2 | tr -d ' ')
        VERSION="${VERSION_MAJOR}.${VERSION_MINOR}.${VERSION_PATCH}"
        BUILD_NUM=$(git rev-list --count HEAD)
        echo "version=${VERSION}" >> $GITHUB_OUTPUT
        echo "build_num=${BUILD_NUM}" >> $GITHUB_OUTPUT

    - name: Build release binaries and generate sources
      run: |
        # Clean and build
        make clean || true
        make generate
        make all
        make test || true
        make libexecinfo.pc || true

    - name: Produce minimal deterministic source tarball and checksums
      id: make_tarball
      run: |
        VERSION=${{ steps.version.outputs.version }}
        BUILD_NUM=${{ steps.version.outputs.build_num }}
        # Use full version (semver + build num) for distribution to match PKGBUILD expectations
        FULL_VERSION="${VERSION}.${BUILD_NUM}"
        TAG="v${FULL_VERSION}"
        BUILDROOT=$(mktemp -d)
        SRCDIR="${BUILDROOT}/libexecinfo-${FULL_VERSION}"
        mkdir -p "$SRCDIR"

        # Core source files
        files=(
          "execinfo.c"
          "execinfo.h"
          "stacktraverse.h"
          "gen.py"
          "Makefile"
          "libexecinfo.pc.in"
          "README.md"
          "LICENSE"
          "CONTRIBUTING.md"
          "test.c"
          "validation-script.sh"
          ".gitignore"
        )

        # Copy files
        for f in "${files[@]}"; do
          if [ -f "$f" ]; then
            cp --preserve=timestamps "$f" "$SRCDIR/"
          fi
        done

        # Copy generated stacktraverse.c if it exists
        if [ -f "stacktraverse.c" ]; then
          cp --preserve=timestamps "stacktraverse.c" "$SRCDIR/"
        fi

        # Make deterministic: set SOURCE_DATE_EPOCH to last commit time
        export SOURCE_DATE_EPOCH=$(git log -1 --format=%ct)

        # Create tarball with stable sorting and fixed owner/group
        TARFILE="libexecinfo-${FULL_VERSION}.tar.gz"
        (cd "$BUILDROOT" && \
          tar --sort=name --owner=0 --group=0 --numeric-owner \
              --mtime="@${SOURCE_DATE_EPOCH}" -czf "$TARFILE" "libexecinfo-${FULL_VERSION}")

        # Move tarball into release directory
        mkdir -p release
        mv "$BUILDROOT/$TARFILE" release/
        sha256sum "release/$TARFILE" > "release/${TARFILE}.sha256"
        md5sum "release/$TARFILE" > "release/${TARFILE}.md5"

        echo "tarball=release/$TARFILE" >> $GITHUB_OUTPUT
        echo "sha256=$(cut -d' ' -f1 release/${TARFILE}.sha256)" >> $GITHUB_OUTPUT
        echo "tag=${TAG}" >> $GITHUB_OUTPUT

    - name: Create or update GitHub release and upload tarball
      run: |
        TARPATH=${{ steps.make_tarball.outputs.tarball }}
        TAG=${{ steps.make_tarball.outputs.tag }}
        SHA256=${{ steps.make_tarball.outputs.sha256 }}
        VERSION=${{ steps.version.outputs.version }}
        # Create the release (if already exists this will fail; we can use gh to create or upload)
        gh release create "${TAG}" --title "libexecinfo ${TAG}" --notes "Automated release ${TAG}" || true
        # Upload or replace the asset
        gh release upload "${TAG}" "release/libexecinfo-${FULL_VERSION}.tar.gz" --clobber
        gh release upload "${TAG}" "release/libexecinfo-${FULL_VERSION}.tar.gz.sha256" --clobber
        gh release upload "${TAG}" "release/libexecinfo-${FULL_VERSION}.tar.gz.md5" --clobber
        echo "Uploaded release libexecinfo-${FULL_VERSION}.tar.gz (sha256: ${SHA256})"

    - name: Generate and Upload PKGBUILD
      run: |
        TAG=${{ steps.make_tarball.outputs.tag }}
        SHA256=${{ steps.make_tarball.outputs.sha256 }}
        VERSION=${{ steps.version.outputs.version }}

        if [ -f "PKGBUILD" ]; then
            echo "Generating release PKGBUILD for version ${VERSION}..."

            # Create a copy for the release
            cp PKGBUILD PKGBUILD.release

            # Update pkgver
            sed -i "s/^pkgver=.*/pkgver=${VERSION}/" PKGBUILD.release

            # Reset pkgrel to 1
            sed -i "s/^pkgrel=.*/pkgrel=1/" PKGBUILD.release

            # Update sha256sums
            sed -i "s/^sha256sums=('.*')/sha256sums=('${SHA256}')/" PKGBUILD.release

            # Display content in log
            echo "::group::Generated PKGBUILD"
            cat PKGBUILD.release
            echo "::endgroup::"

            # Upload to release
            gh release upload "${TAG}" "PKGBUILD.release#PKGBUILD" --clobber
            echo "Uploaded PKGBUILD to release assets"
        else
            echo "PKGBUILD template not found."
        fi
      run: |
        # Configure git with the token
        git config --global user.name "github-actions[bot]"
        git config --global user.email "github-actions[bot]@users.noreply.github.com"

        # Create and push the tag
        git tag -f latest
        git push origin --tags --force

    - name: Cleanup
      if: always()
      run: |
        rm -rf release/
        make clean
